//
// Generated by Bluespec Compiler, version 2022.01 (build 066c7a8)
//
//
// Ports:
// Name                         I/O  size props
// RDY_se_control_status_request_enq  O     1 reg
// se_control_status_request_notFull  O     1 reg
// RDY_se_control_status_request_notFull  O     1 const
// se_control_status_response_first  O    32 reg
// RDY_se_control_status_response_first  O     1 reg
// RDY_se_control_status_response_deq  O     1 reg
// se_control_status_response_notEmpty  O     1 reg
// RDY_se_control_status_response_notEmpty  O     1 const
// mv_assert_core_reset           O     1 reg
// RDY_mv_assert_core_reset       O     1 const
// fo_watch_tohost_control_first_fst  O     1 reg
// RDY_fo_watch_tohost_control_first_fst  O     1 reg
// fo_watch_tohost_control_first_snd  O    64 reg
// RDY_fo_watch_tohost_control_first_snd  O     1 reg
// RDY_fo_watch_tohost_control_deq  O     1 reg
// fo_watch_tohost_control_notEmpty  O     1 reg
// RDY_fo_watch_tohost_control_notEmpty  O     1 const
// fo_verbosity_control_first_fst  O     4 reg
// RDY_fo_verbosity_control_first_fst  O     1 reg
// fo_verbosity_control_first_snd  O    64 reg
// RDY_fo_verbosity_control_first_snd  O     1 reg
// RDY_fo_verbosity_control_deq   O     1 reg
// fo_verbosity_control_notEmpty  O     1 reg
// RDY_fo_verbosity_control_notEmpty  O     1 const
// fo_pc_trace_control_first_fst  O     1 reg
// RDY_fo_pc_trace_control_first_fst  O     1 reg
// fo_pc_trace_control_first_snd  O    64 reg
// RDY_fo_pc_trace_control_first_snd  O     1 reg
// RDY_fo_pc_trace_control_deq    O     1 reg
// fo_pc_trace_control_notEmpty   O     1 reg
// RDY_fo_pc_trace_control_notEmpty  O     1 const
// RDY_fi_tohost_value_enq        O     1 reg
// fi_tohost_value_notFull        O     1 reg
// RDY_fi_tohost_value_notFull    O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// se_control_status_request_enq_x  I    32 reg
// fi_tohost_value_enq_x          I    64 reg
// EN_se_control_status_request_enq  I     1
// EN_se_control_status_response_deq  I     1
// EN_fo_watch_tohost_control_deq  I     1
// EN_fo_verbosity_control_deq    I     1
// EN_fo_pc_trace_control_deq     I     1
// EN_fi_tohost_value_enq         I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkHost_Control_Status(CLK,
			     RST_N,

			     se_control_status_request_enq_x,
			     EN_se_control_status_request_enq,
			     RDY_se_control_status_request_enq,

			     se_control_status_request_notFull,
			     RDY_se_control_status_request_notFull,

			     se_control_status_response_first,
			     RDY_se_control_status_response_first,

			     EN_se_control_status_response_deq,
			     RDY_se_control_status_response_deq,

			     se_control_status_response_notEmpty,
			     RDY_se_control_status_response_notEmpty,

			     mv_assert_core_reset,
			     RDY_mv_assert_core_reset,

			     fo_watch_tohost_control_first_fst,
			     RDY_fo_watch_tohost_control_first_fst,

			     fo_watch_tohost_control_first_snd,
			     RDY_fo_watch_tohost_control_first_snd,

			     EN_fo_watch_tohost_control_deq,
			     RDY_fo_watch_tohost_control_deq,

			     fo_watch_tohost_control_notEmpty,
			     RDY_fo_watch_tohost_control_notEmpty,

			     fo_verbosity_control_first_fst,
			     RDY_fo_verbosity_control_first_fst,

			     fo_verbosity_control_first_snd,
			     RDY_fo_verbosity_control_first_snd,

			     EN_fo_verbosity_control_deq,
			     RDY_fo_verbosity_control_deq,

			     fo_verbosity_control_notEmpty,
			     RDY_fo_verbosity_control_notEmpty,

			     fo_pc_trace_control_first_fst,
			     RDY_fo_pc_trace_control_first_fst,

			     fo_pc_trace_control_first_snd,
			     RDY_fo_pc_trace_control_first_snd,

			     EN_fo_pc_trace_control_deq,
			     RDY_fo_pc_trace_control_deq,

			     fo_pc_trace_control_notEmpty,
			     RDY_fo_pc_trace_control_notEmpty,

			     fi_tohost_value_enq_x,
			     EN_fi_tohost_value_enq,
			     RDY_fi_tohost_value_enq,

			     fi_tohost_value_notFull,
			     RDY_fi_tohost_value_notFull);
  input  CLK;
  input  RST_N;

  // action method se_control_status_request_enq
  input  [31 : 0] se_control_status_request_enq_x;
  input  EN_se_control_status_request_enq;
  output RDY_se_control_status_request_enq;

  // value method se_control_status_request_notFull
  output se_control_status_request_notFull;
  output RDY_se_control_status_request_notFull;

  // value method se_control_status_response_first
  output [31 : 0] se_control_status_response_first;
  output RDY_se_control_status_response_first;

  // action method se_control_status_response_deq
  input  EN_se_control_status_response_deq;
  output RDY_se_control_status_response_deq;

  // value method se_control_status_response_notEmpty
  output se_control_status_response_notEmpty;
  output RDY_se_control_status_response_notEmpty;

  // value method mv_assert_core_reset
  output mv_assert_core_reset;
  output RDY_mv_assert_core_reset;

  // value method fo_watch_tohost_control_first_fst
  output fo_watch_tohost_control_first_fst;
  output RDY_fo_watch_tohost_control_first_fst;

  // value method fo_watch_tohost_control_first_snd
  output [63 : 0] fo_watch_tohost_control_first_snd;
  output RDY_fo_watch_tohost_control_first_snd;

  // action method fo_watch_tohost_control_deq
  input  EN_fo_watch_tohost_control_deq;
  output RDY_fo_watch_tohost_control_deq;

  // value method fo_watch_tohost_control_notEmpty
  output fo_watch_tohost_control_notEmpty;
  output RDY_fo_watch_tohost_control_notEmpty;

  // value method fo_verbosity_control_first_fst
  output [3 : 0] fo_verbosity_control_first_fst;
  output RDY_fo_verbosity_control_first_fst;

  // value method fo_verbosity_control_first_snd
  output [63 : 0] fo_verbosity_control_first_snd;
  output RDY_fo_verbosity_control_first_snd;

  // action method fo_verbosity_control_deq
  input  EN_fo_verbosity_control_deq;
  output RDY_fo_verbosity_control_deq;

  // value method fo_verbosity_control_notEmpty
  output fo_verbosity_control_notEmpty;
  output RDY_fo_verbosity_control_notEmpty;

  // value method fo_pc_trace_control_first_fst
  output fo_pc_trace_control_first_fst;
  output RDY_fo_pc_trace_control_first_fst;

  // value method fo_pc_trace_control_first_snd
  output [63 : 0] fo_pc_trace_control_first_snd;
  output RDY_fo_pc_trace_control_first_snd;

  // action method fo_pc_trace_control_deq
  input  EN_fo_pc_trace_control_deq;
  output RDY_fo_pc_trace_control_deq;

  // value method fo_pc_trace_control_notEmpty
  output fo_pc_trace_control_notEmpty;
  output RDY_fo_pc_trace_control_notEmpty;

  // action method fi_tohost_value_enq
  input  [63 : 0] fi_tohost_value_enq_x;
  input  EN_fi_tohost_value_enq;
  output RDY_fi_tohost_value_enq;

  // value method fi_tohost_value_notFull
  output fi_tohost_value_notFull;
  output RDY_fi_tohost_value_notFull;

  // signals for module outputs
  wire [63 : 0] fo_pc_trace_control_first_snd,
		fo_verbosity_control_first_snd,
		fo_watch_tohost_control_first_snd;
  wire [31 : 0] se_control_status_response_first;
  wire [3 : 0] fo_verbosity_control_first_fst;
  wire RDY_fi_tohost_value_enq,
       RDY_fi_tohost_value_notFull,
       RDY_fo_pc_trace_control_deq,
       RDY_fo_pc_trace_control_first_fst,
       RDY_fo_pc_trace_control_first_snd,
       RDY_fo_pc_trace_control_notEmpty,
       RDY_fo_verbosity_control_deq,
       RDY_fo_verbosity_control_first_fst,
       RDY_fo_verbosity_control_first_snd,
       RDY_fo_verbosity_control_notEmpty,
       RDY_fo_watch_tohost_control_deq,
       RDY_fo_watch_tohost_control_first_fst,
       RDY_fo_watch_tohost_control_first_snd,
       RDY_fo_watch_tohost_control_notEmpty,
       RDY_mv_assert_core_reset,
       RDY_se_control_status_request_enq,
       RDY_se_control_status_request_notFull,
       RDY_se_control_status_response_deq,
       RDY_se_control_status_response_first,
       RDY_se_control_status_response_notEmpty,
       fi_tohost_value_notFull,
       fo_pc_trace_control_first_fst,
       fo_pc_trace_control_notEmpty,
       fo_verbosity_control_notEmpty,
       fo_watch_tohost_control_first_fst,
       fo_watch_tohost_control_notEmpty,
       mv_assert_core_reset,
       se_control_status_request_notFull,
       se_control_status_response_notEmpty;

  // register rg_assert_core_reset
  reg rg_assert_core_reset;
  wire rg_assert_core_reset$D_IN, rg_assert_core_reset$EN;

  // register rg_prev_tohost_value
  reg [15 : 0] rg_prev_tohost_value;
  wire [15 : 0] rg_prev_tohost_value$D_IN;
  wire rg_prev_tohost_value$EN;

  // register rg_req0
  reg [31 : 0] rg_req0;
  wire [31 : 0] rg_req0$D_IN;
  wire rg_req0$EN;

  // register rg_req1
  reg [31 : 0] rg_req1;
  wire [31 : 0] rg_req1$D_IN;
  wire rg_req1$EN;

  // register rg_req2
  reg [31 : 0] rg_req2;
  wire [31 : 0] rg_req2$D_IN;
  wire rg_req2$EN;

  // register rg_req3
  reg [31 : 0] rg_req3;
  wire [31 : 0] rg_req3$D_IN;
  wire rg_req3$EN;

  // register rg_state
  reg [2 : 0] rg_state;
  reg [2 : 0] rg_state$D_IN;
  wire rg_state$EN;

  // register rg_tohost_value
  reg [15 : 0] rg_tohost_value;
  wire [15 : 0] rg_tohost_value$D_IN;
  wire rg_tohost_value$EN;

  // ports of submodule f_host_to_hw
  wire [31 : 0] f_host_to_hw$D_IN, f_host_to_hw$D_OUT;
  wire f_host_to_hw$CLR,
       f_host_to_hw$DEQ,
       f_host_to_hw$EMPTY_N,
       f_host_to_hw$ENQ,
       f_host_to_hw$FULL_N;

  // ports of submodule f_hw_to_host
  reg [31 : 0] f_hw_to_host$D_IN;
  wire [31 : 0] f_hw_to_host$D_OUT;
  wire f_hw_to_host$CLR,
       f_hw_to_host$DEQ,
       f_hw_to_host$EMPTY_N,
       f_hw_to_host$ENQ,
       f_hw_to_host$FULL_N;

  // ports of submodule f_pc_trace_control
  wire [64 : 0] f_pc_trace_control$D_IN, f_pc_trace_control$D_OUT;
  wire f_pc_trace_control$CLR,
       f_pc_trace_control$DEQ,
       f_pc_trace_control$EMPTY_N,
       f_pc_trace_control$ENQ,
       f_pc_trace_control$FULL_N;

  // ports of submodule f_tohost_value
  wire [63 : 0] f_tohost_value$D_IN, f_tohost_value$D_OUT;
  wire f_tohost_value$CLR,
       f_tohost_value$DEQ,
       f_tohost_value$EMPTY_N,
       f_tohost_value$ENQ,
       f_tohost_value$FULL_N;

  // ports of submodule f_verbosity
  wire [67 : 0] f_verbosity$D_IN, f_verbosity$D_OUT;
  wire f_verbosity$CLR,
       f_verbosity$DEQ,
       f_verbosity$EMPTY_N,
       f_verbosity$ENQ,
       f_verbosity$FULL_N;

  // ports of submodule f_watch_tohost
  wire [64 : 0] f_watch_tohost$D_IN, f_watch_tohost$D_OUT;
  wire f_watch_tohost$CLR,
       f_watch_tohost$DEQ,
       f_watch_tohost$EMPTY_N,
       f_watch_tohost$ENQ,
       f_watch_tohost$FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_rl_exec,
       CAN_FIRE_RL_rl_req0,
       CAN_FIRE_RL_rl_req1,
       CAN_FIRE_RL_rl_req2,
       CAN_FIRE_RL_rl_req3,
       CAN_FIRE_RL_rl_tohost_value,
       CAN_FIRE_fi_tohost_value_enq,
       CAN_FIRE_fo_pc_trace_control_deq,
       CAN_FIRE_fo_verbosity_control_deq,
       CAN_FIRE_fo_watch_tohost_control_deq,
       CAN_FIRE_se_control_status_request_enq,
       CAN_FIRE_se_control_status_response_deq,
       WILL_FIRE_RL_rl_exec,
       WILL_FIRE_RL_rl_req0,
       WILL_FIRE_RL_rl_req1,
       WILL_FIRE_RL_rl_req2,
       WILL_FIRE_RL_rl_req3,
       WILL_FIRE_RL_rl_tohost_value,
       WILL_FIRE_fi_tohost_value_enq,
       WILL_FIRE_fo_pc_trace_control_deq,
       WILL_FIRE_fo_verbosity_control_deq,
       WILL_FIRE_fo_watch_tohost_control_deq,
       WILL_FIRE_se_control_status_request_enq,
       WILL_FIRE_se_control_status_response_deq;

  // inputs to muxes for submodule ports
  wire [2 : 0] MUX_rg_state$write_1__VAL_1,
	       MUX_rg_state$write_1__VAL_2,
	       MUX_rg_state$write_1__VAL_3;
  wire MUX_rg_tohost_value$write_1__SEL_1;

  // remaining internal signals
  wire [63 : 0] tohost_addr__h1845;
  wire [31 : 0] v__h1931;
  wire rg_req0_1_BITS_7_TO_3_2_EQ_0_3_OR_rg_req0_1_BI_ETC___d38;

  // action method se_control_status_request_enq
  assign RDY_se_control_status_request_enq = f_host_to_hw$FULL_N ;
  assign CAN_FIRE_se_control_status_request_enq = f_host_to_hw$FULL_N ;
  assign WILL_FIRE_se_control_status_request_enq =
	     EN_se_control_status_request_enq ;

  // value method se_control_status_request_notFull
  assign se_control_status_request_notFull = f_host_to_hw$FULL_N ;
  assign RDY_se_control_status_request_notFull = 1'd1 ;

  // value method se_control_status_response_first
  assign se_control_status_response_first = f_hw_to_host$D_OUT ;
  assign RDY_se_control_status_response_first = f_hw_to_host$EMPTY_N ;

  // action method se_control_status_response_deq
  assign RDY_se_control_status_response_deq = f_hw_to_host$EMPTY_N ;
  assign CAN_FIRE_se_control_status_response_deq = f_hw_to_host$EMPTY_N ;
  assign WILL_FIRE_se_control_status_response_deq =
	     EN_se_control_status_response_deq ;

  // value method se_control_status_response_notEmpty
  assign se_control_status_response_notEmpty = f_hw_to_host$EMPTY_N ;
  assign RDY_se_control_status_response_notEmpty = 1'd1 ;

  // value method mv_assert_core_reset
  assign mv_assert_core_reset = rg_assert_core_reset ;
  assign RDY_mv_assert_core_reset = 1'd1 ;

  // value method fo_watch_tohost_control_first_fst
  assign fo_watch_tohost_control_first_fst = f_watch_tohost$D_OUT[64] ;
  assign RDY_fo_watch_tohost_control_first_fst = f_watch_tohost$EMPTY_N ;

  // value method fo_watch_tohost_control_first_snd
  assign fo_watch_tohost_control_first_snd = f_watch_tohost$D_OUT[63:0] ;
  assign RDY_fo_watch_tohost_control_first_snd = f_watch_tohost$EMPTY_N ;

  // action method fo_watch_tohost_control_deq
  assign RDY_fo_watch_tohost_control_deq = f_watch_tohost$EMPTY_N ;
  assign CAN_FIRE_fo_watch_tohost_control_deq = f_watch_tohost$EMPTY_N ;
  assign WILL_FIRE_fo_watch_tohost_control_deq =
	     EN_fo_watch_tohost_control_deq ;

  // value method fo_watch_tohost_control_notEmpty
  assign fo_watch_tohost_control_notEmpty = f_watch_tohost$EMPTY_N ;
  assign RDY_fo_watch_tohost_control_notEmpty = 1'd1 ;

  // value method fo_verbosity_control_first_fst
  assign fo_verbosity_control_first_fst = f_verbosity$D_OUT[67:64] ;
  assign RDY_fo_verbosity_control_first_fst = f_verbosity$EMPTY_N ;

  // value method fo_verbosity_control_first_snd
  assign fo_verbosity_control_first_snd = f_verbosity$D_OUT[63:0] ;
  assign RDY_fo_verbosity_control_first_snd = f_verbosity$EMPTY_N ;

  // action method fo_verbosity_control_deq
  assign RDY_fo_verbosity_control_deq = f_verbosity$EMPTY_N ;
  assign CAN_FIRE_fo_verbosity_control_deq = f_verbosity$EMPTY_N ;
  assign WILL_FIRE_fo_verbosity_control_deq = EN_fo_verbosity_control_deq ;

  // value method fo_verbosity_control_notEmpty
  assign fo_verbosity_control_notEmpty = f_verbosity$EMPTY_N ;
  assign RDY_fo_verbosity_control_notEmpty = 1'd1 ;

  // value method fo_pc_trace_control_first_fst
  assign fo_pc_trace_control_first_fst = f_pc_trace_control$D_OUT[64] ;
  assign RDY_fo_pc_trace_control_first_fst = f_pc_trace_control$EMPTY_N ;

  // value method fo_pc_trace_control_first_snd
  assign fo_pc_trace_control_first_snd = f_pc_trace_control$D_OUT[63:0] ;
  assign RDY_fo_pc_trace_control_first_snd = f_pc_trace_control$EMPTY_N ;

  // action method fo_pc_trace_control_deq
  assign RDY_fo_pc_trace_control_deq = f_pc_trace_control$EMPTY_N ;
  assign CAN_FIRE_fo_pc_trace_control_deq = f_pc_trace_control$EMPTY_N ;
  assign WILL_FIRE_fo_pc_trace_control_deq = EN_fo_pc_trace_control_deq ;

  // value method fo_pc_trace_control_notEmpty
  assign fo_pc_trace_control_notEmpty = f_pc_trace_control$EMPTY_N ;
  assign RDY_fo_pc_trace_control_notEmpty = 1'd1 ;

  // action method fi_tohost_value_enq
  assign RDY_fi_tohost_value_enq = f_tohost_value$FULL_N ;
  assign CAN_FIRE_fi_tohost_value_enq = f_tohost_value$FULL_N ;
  assign WILL_FIRE_fi_tohost_value_enq = EN_fi_tohost_value_enq ;

  // value method fi_tohost_value_notFull
  assign fi_tohost_value_notFull = f_tohost_value$FULL_N ;
  assign RDY_fi_tohost_value_notFull = 1'd1 ;

  // submodule f_host_to_hw
  FIFO2 #(.width(32'd32), .guarded(1'd1)) f_host_to_hw(.RST(RST_N),
						       .CLK(CLK),
						       .D_IN(f_host_to_hw$D_IN),
						       .ENQ(f_host_to_hw$ENQ),
						       .DEQ(f_host_to_hw$DEQ),
						       .CLR(f_host_to_hw$CLR),
						       .D_OUT(f_host_to_hw$D_OUT),
						       .FULL_N(f_host_to_hw$FULL_N),
						       .EMPTY_N(f_host_to_hw$EMPTY_N));

  // submodule f_hw_to_host
  FIFO2 #(.width(32'd32), .guarded(1'd1)) f_hw_to_host(.RST(RST_N),
						       .CLK(CLK),
						       .D_IN(f_hw_to_host$D_IN),
						       .ENQ(f_hw_to_host$ENQ),
						       .DEQ(f_hw_to_host$DEQ),
						       .CLR(f_hw_to_host$CLR),
						       .D_OUT(f_hw_to_host$D_OUT),
						       .FULL_N(f_hw_to_host$FULL_N),
						       .EMPTY_N(f_hw_to_host$EMPTY_N));

  // submodule f_pc_trace_control
  FIFO2 #(.width(32'd65), .guarded(1'd1)) f_pc_trace_control(.RST(RST_N),
							     .CLK(CLK),
							     .D_IN(f_pc_trace_control$D_IN),
							     .ENQ(f_pc_trace_control$ENQ),
							     .DEQ(f_pc_trace_control$DEQ),
							     .CLR(f_pc_trace_control$CLR),
							     .D_OUT(f_pc_trace_control$D_OUT),
							     .FULL_N(f_pc_trace_control$FULL_N),
							     .EMPTY_N(f_pc_trace_control$EMPTY_N));

  // submodule f_tohost_value
  FIFO2 #(.width(32'd64), .guarded(1'd1)) f_tohost_value(.RST(RST_N),
							 .CLK(CLK),
							 .D_IN(f_tohost_value$D_IN),
							 .ENQ(f_tohost_value$ENQ),
							 .DEQ(f_tohost_value$DEQ),
							 .CLR(f_tohost_value$CLR),
							 .D_OUT(f_tohost_value$D_OUT),
							 .FULL_N(f_tohost_value$FULL_N),
							 .EMPTY_N(f_tohost_value$EMPTY_N));

  // submodule f_verbosity
  FIFO2 #(.width(32'd68), .guarded(1'd1)) f_verbosity(.RST(RST_N),
						      .CLK(CLK),
						      .D_IN(f_verbosity$D_IN),
						      .ENQ(f_verbosity$ENQ),
						      .DEQ(f_verbosity$DEQ),
						      .CLR(f_verbosity$CLR),
						      .D_OUT(f_verbosity$D_OUT),
						      .FULL_N(f_verbosity$FULL_N),
						      .EMPTY_N(f_verbosity$EMPTY_N));

  // submodule f_watch_tohost
  FIFO2 #(.width(32'd65), .guarded(1'd1)) f_watch_tohost(.RST(RST_N),
							 .CLK(CLK),
							 .D_IN(f_watch_tohost$D_IN),
							 .ENQ(f_watch_tohost$ENQ),
							 .DEQ(f_watch_tohost$DEQ),
							 .CLR(f_watch_tohost$CLR),
							 .D_OUT(f_watch_tohost$D_OUT),
							 .FULL_N(f_watch_tohost$FULL_N),
							 .EMPTY_N(f_watch_tohost$EMPTY_N));

  // rule RL_rl_req0
  assign CAN_FIRE_RL_rl_req0 = f_host_to_hw$EMPTY_N && rg_state == 3'd0 ;
  assign WILL_FIRE_RL_rl_req0 = CAN_FIRE_RL_rl_req0 ;

  // rule RL_rl_req1
  assign CAN_FIRE_RL_rl_req1 = f_host_to_hw$EMPTY_N && rg_state == 3'd1 ;
  assign WILL_FIRE_RL_rl_req1 = CAN_FIRE_RL_rl_req1 ;

  // rule RL_rl_req2
  assign CAN_FIRE_RL_rl_req2 = f_host_to_hw$EMPTY_N && rg_state == 3'd2 ;
  assign WILL_FIRE_RL_rl_req2 = CAN_FIRE_RL_rl_req2 ;

  // rule RL_rl_req3
  assign CAN_FIRE_RL_rl_req3 = f_host_to_hw$EMPTY_N && rg_state == 3'd3 ;
  assign WILL_FIRE_RL_rl_req3 = CAN_FIRE_RL_rl_req3 ;

  // rule RL_rl_exec
  assign CAN_FIRE_RL_rl_exec =
	     f_hw_to_host$FULL_N &&
	     rg_req0_1_BITS_7_TO_3_2_EQ_0_3_OR_rg_req0_1_BI_ETC___d38 &&
	     rg_state == 3'd4 ;
  assign WILL_FIRE_RL_rl_exec = CAN_FIRE_RL_rl_exec ;

  // rule RL_rl_tohost_value
  assign CAN_FIRE_RL_rl_tohost_value = f_tohost_value$EMPTY_N ;
  assign WILL_FIRE_RL_rl_tohost_value =
	     f_tohost_value$EMPTY_N && !WILL_FIRE_RL_rl_exec ;

  // inputs to muxes for submodule ports
  assign MUX_rg_tohost_value$write_1__SEL_1 =
	     WILL_FIRE_RL_rl_exec && rg_req0[7:3] == 5'd1 ;
  assign MUX_rg_state$write_1__VAL_1 =
	     (f_host_to_hw$D_OUT[2:0] == 3'd0) ? 3'd4 : 3'd1 ;
  assign MUX_rg_state$write_1__VAL_2 = (rg_req0[2:0] == 3'd1) ? 3'd4 : 3'd2 ;
  assign MUX_rg_state$write_1__VAL_3 = (rg_req0[2:0] == 3'd2) ? 3'd4 : 3'd3 ;

  // register rg_assert_core_reset
  assign rg_assert_core_reset$D_IN = rg_req0[31:8] != 24'd0 ;
  assign rg_assert_core_reset$EN = MUX_rg_tohost_value$write_1__SEL_1 ;

  // register rg_prev_tohost_value
  assign rg_prev_tohost_value$D_IN =
	     (rg_req0[7:3] == 5'd1) ? 16'd0 : rg_tohost_value ;
  assign rg_prev_tohost_value$EN =
	     WILL_FIRE_RL_rl_exec &&
	     (rg_req0[7:3] == 5'd1 ||
	      rg_req0[7:3] == 5'd6 &&
	      rg_prev_tohost_value != rg_tohost_value) ;

  // register rg_req0
  assign rg_req0$D_IN = f_host_to_hw$D_OUT ;
  assign rg_req0$EN = CAN_FIRE_RL_rl_req0 ;

  // register rg_req1
  assign rg_req1$D_IN = f_host_to_hw$D_OUT ;
  assign rg_req1$EN = CAN_FIRE_RL_rl_req1 ;

  // register rg_req2
  assign rg_req2$D_IN = f_host_to_hw$D_OUT ;
  assign rg_req2$EN = CAN_FIRE_RL_rl_req2 ;

  // register rg_req3
  assign rg_req3$D_IN = f_host_to_hw$D_OUT ;
  assign rg_req3$EN = CAN_FIRE_RL_rl_req3 ;

  // register rg_state
  always@(WILL_FIRE_RL_rl_req0 or
	  MUX_rg_state$write_1__VAL_1 or
	  WILL_FIRE_RL_rl_req1 or
	  MUX_rg_state$write_1__VAL_2 or
	  WILL_FIRE_RL_rl_req2 or
	  MUX_rg_state$write_1__VAL_3 or
	  WILL_FIRE_RL_rl_exec or WILL_FIRE_RL_rl_req3)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_rl_req0: rg_state$D_IN = MUX_rg_state$write_1__VAL_1;
      WILL_FIRE_RL_rl_req1: rg_state$D_IN = MUX_rg_state$write_1__VAL_2;
      WILL_FIRE_RL_rl_req2: rg_state$D_IN = MUX_rg_state$write_1__VAL_3;
      WILL_FIRE_RL_rl_exec: rg_state$D_IN = 3'd0;
      WILL_FIRE_RL_rl_req3: rg_state$D_IN = 3'd4;
      default: rg_state$D_IN = 3'b010 /* unspecified value */ ;
    endcase
  end
  assign rg_state$EN =
	     WILL_FIRE_RL_rl_req0 || WILL_FIRE_RL_rl_req1 ||
	     WILL_FIRE_RL_rl_req2 ||
	     WILL_FIRE_RL_rl_exec ||
	     WILL_FIRE_RL_rl_req3 ;

  // register rg_tohost_value
  assign rg_tohost_value$D_IN =
	     MUX_rg_tohost_value$write_1__SEL_1 ?
	       16'd0 :
	       f_tohost_value$D_OUT[15:0] ;
  assign rg_tohost_value$EN =
	     WILL_FIRE_RL_rl_exec && rg_req0[7:3] == 5'd1 ||
	     WILL_FIRE_RL_rl_tohost_value ;

  // submodule f_host_to_hw
  assign f_host_to_hw$D_IN = se_control_status_request_enq_x ;
  assign f_host_to_hw$ENQ = EN_se_control_status_request_enq ;
  assign f_host_to_hw$DEQ =
	     WILL_FIRE_RL_rl_req3 || WILL_FIRE_RL_rl_req2 ||
	     WILL_FIRE_RL_rl_req1 ||
	     WILL_FIRE_RL_rl_req0 ;
  assign f_host_to_hw$CLR = 1'b0 ;

  // submodule f_hw_to_host
  always@(rg_req0 or v__h1931)
  begin
    case (rg_req0[7:3])
      5'd0, 5'd1, 5'd5, 5'd7, 5'd8: f_hw_to_host$D_IN = 32'd0;
      5'd6: f_hw_to_host$D_IN = v__h1931;
      default: f_hw_to_host$D_IN = 32'd2;
    endcase
  end
  assign f_hw_to_host$ENQ = CAN_FIRE_RL_rl_exec ;
  assign f_hw_to_host$DEQ = EN_se_control_status_response_deq ;
  assign f_hw_to_host$CLR = 1'b0 ;

  // submodule f_pc_trace_control
  assign f_pc_trace_control$D_IN =
	     (rg_req0[2:0] == 3'd0) ?
	       65'h0AAAAAAAAAAAAAAAA :
	       { 33'h100000000, rg_req1 } ;
  assign f_pc_trace_control$ENQ =
	     WILL_FIRE_RL_rl_exec && rg_req0[7:3] == 5'd7 ;
  assign f_pc_trace_control$DEQ = EN_fo_pc_trace_control_deq ;
  assign f_pc_trace_control$CLR = MUX_rg_tohost_value$write_1__SEL_1 ;

  // submodule f_tohost_value
  assign f_tohost_value$D_IN = fi_tohost_value_enq_x ;
  assign f_tohost_value$ENQ = EN_fi_tohost_value_enq ;
  assign f_tohost_value$DEQ = WILL_FIRE_RL_rl_tohost_value ;
  assign f_tohost_value$CLR = MUX_rg_tohost_value$write_1__SEL_1 ;

  // submodule f_verbosity
  assign f_verbosity$D_IN = { rg_req0[11:8], tohost_addr__h1845 } ;
  assign f_verbosity$ENQ = WILL_FIRE_RL_rl_exec && rg_req0[7:3] == 5'd8 ;
  assign f_verbosity$DEQ = EN_fo_verbosity_control_deq ;
  assign f_verbosity$CLR = MUX_rg_tohost_value$write_1__SEL_1 ;

  // submodule f_watch_tohost
  assign f_watch_tohost$D_IN = { rg_req0[2:0] != 3'd0, tohost_addr__h1845 } ;
  assign f_watch_tohost$ENQ = WILL_FIRE_RL_rl_exec && rg_req0[7:3] == 5'd5 ;
  assign f_watch_tohost$DEQ = EN_fo_watch_tohost_control_deq ;
  assign f_watch_tohost$CLR = MUX_rg_tohost_value$write_1__SEL_1 ;

  // remaining internal signals
  assign rg_req0_1_BITS_7_TO_3_2_EQ_0_3_OR_rg_req0_1_BI_ETC___d38 =
	     rg_req0[7:3] == 5'd0 || rg_req0[7:3] == 5'd1 ||
	     ((rg_req0[7:3] == 5'd5) ?
		f_watch_tohost$FULL_N :
		((rg_req0[7:3] == 5'd7) ?
		   f_pc_trace_control$FULL_N :
		   rg_req0[7:3] != 5'd8 || f_verbosity$FULL_N)) ;
  assign tohost_addr__h1845 = { rg_req2, rg_req1 } ;
  assign v__h1931 = { rg_tohost_value, 16'h0 } ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        rg_assert_core_reset <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rg_prev_tohost_value <= `BSV_ASSIGNMENT_DELAY 16'd0;
	rg_state <= `BSV_ASSIGNMENT_DELAY 3'd0;
	rg_tohost_value <= `BSV_ASSIGNMENT_DELAY 16'd0;
      end
    else
      begin
        if (rg_assert_core_reset$EN)
	  rg_assert_core_reset <= `BSV_ASSIGNMENT_DELAY
	      rg_assert_core_reset$D_IN;
	if (rg_prev_tohost_value$EN)
	  rg_prev_tohost_value <= `BSV_ASSIGNMENT_DELAY
	      rg_prev_tohost_value$D_IN;
	if (rg_state$EN) rg_state <= `BSV_ASSIGNMENT_DELAY rg_state$D_IN;
	if (rg_tohost_value$EN)
	  rg_tohost_value <= `BSV_ASSIGNMENT_DELAY rg_tohost_value$D_IN;
      end
    if (rg_req0$EN) rg_req0 <= `BSV_ASSIGNMENT_DELAY rg_req0$D_IN;
    if (rg_req1$EN) rg_req1 <= `BSV_ASSIGNMENT_DELAY rg_req1$D_IN;
    if (rg_req2$EN) rg_req2 <= `BSV_ASSIGNMENT_DELAY rg_req2$D_IN;
    if (rg_req3$EN) rg_req3 <= `BSV_ASSIGNMENT_DELAY rg_req3$D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    rg_assert_core_reset = 1'h0;
    rg_prev_tohost_value = 16'hAAAA;
    rg_req0 = 32'hAAAAAAAA;
    rg_req1 = 32'hAAAAAAAA;
    rg_req2 = 32'hAAAAAAAA;
    rg_req3 = 32'hAAAAAAAA;
    rg_state = 3'h2;
    rg_tohost_value = 16'hAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_exec && rg_req0[7:3] == 5'd0)
	$display("Host_Control_Status: host_to_hw_req: ping/noop");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_exec && rg_req0[7:3] == 5'd1 &&
	  rg_req0[31:8] == 24'd0)
	$display("Host_Control_Status: Deassert Core Reset");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_exec && rg_req0[7:3] == 5'd1 &&
	  rg_req0[31:8] != 24'd0)
	$display("Host_Control_Status: Assert Core Reset");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_exec && rg_req0[7:3] == 5'd5 &&
	  rg_req0[2:0] == 3'd0)
	$display("Host_Control_Status: watch_tohost_off");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_exec && rg_req0[7:3] == 5'd5 &&
	  rg_req0[2:0] != 3'd0)
	$display("Host_Control_Status: watch_tohost_on, addr %0h",
		 tohost_addr__h1845);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_exec && rg_req0[7:3] == 5'd7 &&
	  rg_req0[2:0] == 3'd0)
	$display("Host_Control_Status: PC trace off");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_exec && rg_req0[7:3] == 5'd7 &&
	  rg_req0[2:0] != 3'd0)
	$display("Host_Control_Status: PC trace on: interval %0h", rg_req1);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_exec && rg_req0[7:3] == 5'd8)
	$display("Host_Control_Status: set_sim_verbosity %0d logdelay %0h",
		 rg_req0[11:8],
		 tohost_addr__h1845);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_exec && rg_req0[7:3] != 5'd0 &&
	  rg_req0[7:3] != 5'd1 &&
	  rg_req0[7:3] != 5'd5 &&
	  rg_req0[7:3] != 5'd6 &&
	  rg_req0[7:3] != 5'd7 &&
	  rg_req0[7:3] != 5'd8)
	$display("Host_ontrol_Status: unsupported command %0h; request word 0 is %0h",
		 rg_req0[7:3],
		 rg_req0);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_exec && rg_req0[7:3] != 5'd0 &&
	  rg_req0[7:3] != 5'd1 &&
	  rg_req0[7:3] != 5'd5 &&
	  rg_req0[7:3] != 5'd6 &&
	  rg_req0[7:3] != 5'd7 &&
	  rg_req0[7:3] != 5'd8)
	$display("    %m");
  end
  // synopsys translate_on
endmodule  // mkHost_Control_Status

