= Synthesis Setup for FPGAs
:revnumber: v1.0
:revdate: 2022-05-09
:sectnums:
:toc:
:toclevels: 3
:toc-title: Contents
:description: Semi-automated synthesis tool-flow for Xilinx and Microsemi devices.

This repository contains scripts and a semi-automated setup to
synthesize a RTL module in Xilinx Vivado and Microsemi Libero.

== Installation / Getting Started

Point `SYN_REPO` to this directory. Ensure that you have `vivado`
and/or `libero` setup depending on the FPGA you are targeting. 

These scripts have been tested with Vivado 2019.1 and Libero SoC
v12.6. 

```
$ # Assuming that you are in the Flute directory

$ cd synthesis

$ export SYN_REPO=$(pwd)
```

== Synthesizing with Vivado (Xilinx)

In order to synthesize targeting a Xilinx device, run the top-level synthesis script from `$SYN_REPO/xilinx`.
The top-level script to run synthesis is `$SYN_REPO/xilinx/run_synth.sh`.
A work folder, `work-<top-level>-<date-stamp>` is created to run synthesis.

```
$ cd $SYN_REPO/xilinx
$ ./run_synth.sh --help

usage: run_synth.sh [[-c clk_period ] [-s script] [-t top-level] [-f rtl-dir] [-d device] [-j njobs] | [-h]]
Ensure SYN_REPO points to your synthesis folder
```

`script`, if not specified, defaults to
`$SYN_REPO/xilinx/synthesize.tcl`, which is a soft-link to the
standard sythesis and implementation flow supported by Vivado
2019.1

`device`, if not specified, defaults to artix7 (xc7a100tcsg324-1). 
Other devices: kintex7, virtex7, virtexu, virtexuplus, kintexu, kintexuplus

`njobs`, if not specified, defaults to 2

The flow wraps top-level with shift-register wrapper and runs
synthesis in a work folder created in PWD. 

NOTE: for automatic wrapper generation to work correctly, the
top-level module should be defined exclusively in its own file

For instance, the following command runs synthesis on `virtex7`
using `mkBSCore` as the top-level module using the default
synthesis flow.

The RTL is assumed to be in `/tmp/rtl_dir` in this example. The RTL
directory should contain all the modules to be synthesized except
the library modules which are read from the
`common/src_bsc_lib_RTL` directory.

```
$ ./run_synth.sh -c 5.0 -t mkBSCore -f /tmp/rtl_dir
```

Reports are placed in `work-<top-level>-<date-stamp>/impl_*/`.

=== Advanced Use

The default synthesis strategy uses the default Vivado 2019
strategies for synthesis and implementation. To use alternate
strategies use the `-s` command line switch to specify another
synthesis flow. Example alternate flows are in the
`SYN_REPO/xilinx` folder. Some of the alternate flows may take
long run times.

To add timing exceptions to your run, create an
`$SYN_REPO/xilinx/exceptions.xdc` file before running
`run_synth.sh`. The script looks for this file and adds the
exceptions to the run.

== Synthesizing with Libero (Microsemi)

In order to synthesize targeting a Microsemi device, run the
top-level synthesis script from `$SYN_REPO/microsemi`.
The top-level script to run synthesis is `$SYN_REPO/microsemi/run_synth.sh`. 

```
$ cd $SYN_REPO/microsemi
$ ./run_synth.sh --help

usage: run_synth.sh [[-c clk_period ] [-t top-level] [-f rtl-dir] | [-h]]
Ensure SYN_REPO points to root of your synth tools repo
```

For instance, the following command runs synthesis on a microsemi
device using `mkBSCore` as the top-level module.  The RTL is
assumed to be in `/tmp/rtl_dir` in this example. The RTL directory
should contain all the modules to be synthesized except the library
modules which are read from the `common/src_bsc_lib_RTL` directory.

```
$ ./run_synth.sh -c 10.0 -t mkBSCore -f /tmp/rtl_dir
```

=== Advanced Use

To add timing exceptions to your run, create an
`$SYN_REPO/mixrosemi/exceptions*.sdc` file before running
`run_synth.sh`. The script looks for these file and adds the
exceptions to the run. Libero's constraint manger supports
different exceptions for synthesis, pnr and timing analysis.

== Wrapper Generation

In order to restrict the number of ports that need to be connected
to the FPGA's IO pins, the module's pinout is wrapped with a shift
register which is generated by the script,
`$SYN_REPO/common/count_ports.py`

This script parses the port-list of the top-level module and
generates a wrapper that ties all the inputs and outputs to shift
registers. This allows all timing analysis in the actual design to
be register to register paths and obviates the need for mapping the
top-level ports to the FPGA devices IOs. The script is not a
complete Verilog parser and has been tested with Verilog RTL
generated from BSV sources. 
